"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const frameFuntions_1 = require("./frameFuntions");
const plots_1 = require("./plots");
const stats_1 = require("./stats");
/**
 * data:
 *     data: [[]]
 *     header_: ""
 *     meta: {}
 *     mid: 0
 */
// TODO: continual dropping decreases meta data indefinetley(really bad) affecting stats
class Frame {
    constructor(table, data) {
        this.table = undefined;
        this.Header_ = [];
        this.table = table;
        this.Pdata = data;
        if (typeof this.Pdata.header_ === "string") {
            this.Header_ = this.Pdata.header_.split(",");
            this.Header_.unshift(" ");
            this.Header_[this.Header_.length - 1] = this.Header_[this.Header_.length - 1].replace("\r", "");
        }
        else {
            this.Header_ = this.Pdata.header_;
        }
    }
    get shape() {
        return [this.Pdata.data.length, this.Pdata.data[0].length];
    }
    get columns() {
        return this.Header_;
    }
}
exports.default = Frame;
Frame.prototype.returnFrame = frameFuntions_1.returnFrame;
Frame.prototype.head = frameFuntions_1.head;
Frame.prototype.tail = frameFuntions_1.tail;
Frame.prototype.map = frameFuntions_1.map;
Frame.prototype.slice = frameFuntions_1.slice;
Frame.prototype.isNull = frameFuntions_1.isNull;
Frame.prototype.query = frameFuntions_1.query;
Frame.prototype.drop = frameFuntions_1.drop;
Frame.prototype.dropna = frameFuntions_1.dropna;
Frame.prototype.replace = frameFuntions_1.replace;
Frame.prototype.unique = frameFuntions_1.unique;
Frame.prototype.getCol = frameFuntions_1.getCol;
Frame.prototype.apply_along_axis = frameFuntions_1.apply_along_axis;
Frame.prototype.counter = frameFuntions_1.count;
Frame.prototype.rename = frameFuntions_1.rename;
Frame.prototype.reset = frameFuntions_1.resetIndex;
Frame.prototype.fillna = function (method) {
    if (method === "mean") {
    }
    else if (method === "avg") {
    }
    else if (method === "Most") {
    }
    else {
        throw new Error(`${method} not implemented yet`);
    }
};
//plots 
Frame.prototype.hist = plots_1.plot_histogram;
Frame.prototype.scatterM = plots_1.make_scatter_matrix;
Frame.prototype.scatter = plots_1.twoD;
// Frame.prototype.validate  = function(){
//     let status:Record<any, any> =  {status: true}
//     this.Pdata.data.forEach((arr:Array<any>,i:number)=> {
//         arr.forEach((val, j)=> {
//             if(typeof val === "string"){
//                status.status = false;
//                status.rowNcol = {i, j}
//                return
//             }
//         })
//         return
//     })
//     return status
// }
Frame.prototype.toWasm = function () {
};
Frame.prototype.group_by = frameFuntions_1.group_by;
Frame.prototype.newCol = function (arr, header, type, callback) {
    if (arr.length !== this.Pdata.data.length)
        throw new Error("new column length !== dataframe len");
    else {
        this.Pdata.data.forEach((arr_, index) => {
            arr_.push(arr[index]);
        });
        this.Header_.push(header);
    }
    let obj = {
        data: {
            data: this.Pdata.data,
            header_: this.Header_,
            notNeeded: false
        }
    };
    let m = this.Header_.length;
    this.Pdata.meta[m] = type;
    // handle updating the meta with new data
    this.returnFrame(obj, this.Pdata.data, this.Header_, true, callback);
};
Frame.prototype.basicStat = stats_1.workerMean;
Frame.prototype.writeCSV = frameFuntions_1.writeCsv;
// function fillna(method, inplace)
//function(value:any, toReplace:any, callback:Function, inPlace: false){
//     let headers:Array<any> = JSON.parse(JSON.stringify(this.Header_))
//     let data: Array<Array<any>> = JSON.parse(JSON.stringify(this.Pdata.data))
//     data.forEach((arr, i)=> {
//         arr.forEach((val, j)=> {
//              if(val === toReplace){
//                  arr[j] = value
//              }
//         })
//     })
//     if(inPlace){
//         const work = new Worker("./workers/tableworker.js")
//         let obj = {
//         data: {
//             data: data,
//             header_:  headers,
//             notNeeded: false
//         }
//     }
//     work.postMessage(obj)
//     work.onmessage = e => {
//             this.table = e.data
//             this.Pdata.data = data
//             this.Pdata.header_ = headers
//             this.Header_ = headers
//             callback(this)
//             work.terminate()
//     }
//   }
//   else{
//     const work = new Worker("./workers/tableworker.js")
//     let obj = {
//     data: {
//         data: data,
//         header_:  headers,
//         notNeeded: false
//     }
// }
//     work.postMessage(obj)
//     work.onmessage = e => {
//         let dataCopy = JSON.stringify(data)
//             callback(new Frame(e.data, JSON.parse(dataCopy)))
//             work.terminate()
//     }
//     }
// }
// unique in columns
//function(column:any){
//     let index:number = this.Header_.indexOf(column)
//    if(index === 0){
//     // if(typeof this.Pdata.header_ === "string"){
//     //     index = this.Pdata.header_.split(",").length 
//     //  }else{
//     //      index = this.Pdata.header_.length 
//     //  }
//    }
//     let unique:Array<any> = []
//     this.Pdata.data.forEach((arr:Array<any>, i:number)=> {
//        if(!unique.includes(arr[index])){
//             unique.push(arr[index])
//        }     
//     })
//     return unique
// }
// map 
// fix drop with headers
// function(column:string){
//     let index:number = this.Header_.indexOf(column)
//     let col: Array<any> = []
//     if(index >= 0){
//         this.Pdata.data.forEach((arr:Array<any>, i:number)=> {
//             col.push(arr[index])     
//        })
//     }
//     else {
//         throw new Error(`${column} probably does not exist`);
//     }
//      return col
// }
//function(axis:number, fn: Function,where:string, callback:Function,inPlace:boolean = false){
//     let headers:Array<any> = JSON.parse(JSON.stringify(this.Header_))
//     let data: Array<Array<any>> = JSON.parse(JSON.stringify(this.Pdata.data))
//     if(axis === 1){
//        let index = headers.indexOf(where)
//         if(index !== -1){
//              data.forEach((arr:Array<any>, i)=> {
//                  arr[index] = fn(arr[index])
//              })
//         }
//         else{
//             throw new Error(`${where} does not exist, i think`)
//         }
//     }
//     else if(axis === 0){
//         // row 
//         if(where === "all"){
//             // for all rows
//             data.forEach((arr:Array<any>, i)=> {
//                    arr.forEach((val, j)=> {
//                        arr[j] = fn(val)
//                    })
//             })
//         }
//         else {
//             let row:number =  parseInt(where)
//             let data_:Array<any> = data[row]
//          data_.forEach((val, index)=> {
//              data[index] = fn(val)
//          })
//          data[row] = data_
//         }
//     }
//     if(inPlace){
//         const work = new Worker("./workers/tableworker.js")
//         let obj = {
//         data: {
//             data: data,
//             header_:  headers,
//             notNeeded: false
//         }
//     }
//     work.postMessage(obj)
//     work.onmessage = e => {
//             this.table = e.data
//             this.Pdata.data = data
//             this.Pdata.header_ = headers
//             this.Header_ = headers
//             callback(this)
//             work.terminate()
//     }
//   }
//   else{
//     const work = new Worker("./workers/tableworker.js")
//     let obj = {
//     data: {
//         data: data,
//         header_:  headers,
//         notNeeded: false
//     }
// }
//     work.postMessage(obj)
//     work.onmessage = e => {
//         let dataCopy = JSON.stringify(data)
//             callback(new Frame(e.data, JSON.parse(dataCopy)))
//             work.terminate()
//     }
//     }
// }
//function(inPlace:boolean = false,callback:Function){
//     let headers:Array<any> = JSON.parse(JSON.stringify(this.Header_))
//     let data: Array<Array<any>> = JSON.parse(JSON.stringify(this.Pdata.data))
//      for(let i = data.length - 1; i >= 0; i--){
//          if(data[i].includes("NaN")){
//              data.splice(i, 1)
//          }
//      }
//     data.forEach((arr, index)=> {
//         arr[0] = index
//     })
//     if(inPlace){
//         const work = new Worker("./workers/tableworker.js")
//         let obj = {
//         data: {
//             data: data,
//             header_:  headers,
//             notNeeded: false
//         }
//     }
//     work.postMessage(obj)
//     work.onmessage = e => {
//             this.table = e.data
//             this.Pdata.data = data
//             this.Pdata.header_ = headers
//             this.Header_ = headers
//             callback(this)
//             work.terminate()
//     }
//   }
//   else{
//     const work = new Worker("./workers/tableworker.js")
//     let obj = {
//     data: {
//         data: data,
//         header_:  headers,
//         notNeeded: false
//     }
// }
//     work.postMessage(obj)
//     work.onmessage = e => {
//         let dataCopy = JSON.stringify(data)
//             this.Pdata.header_ = headers
//             this.Header_ = headers
//             callback(new Frame(e.data, JSON.parse(dataCopy)))
//             work.terminate()
//     }
//     }
// }
// = function(values:Record<any, any>, column:any,callback:Function, inPlace:boolean = false){
//     let index:number
//     let headers:Array<any> = []
//     if(typeof this.Pdata.header_ === "string"){
//         headers = JSON.parse(JSON.stringify(this.Pdata.header_.split(",")))
//         headers.unshift(" ")
//     }else{
//         headers = JSON.parse(JSON.stringify(this.Pdata.header_))
//     }
//     let data: Array<Array<any>> = JSON.parse(JSON.stringify(this.Pdata.data))
//     index = headers.indexOf(column)
//     data.forEach((arr:Array<any>, i:number)=> {
//         if(values[arr[index]]){
//              arr[index] = values[arr[index]]
//         }     
//      })
//      if(inPlace){
//         const work = new Worker("./workers/tableworker.js")
//         let obj = {
//         data: {
//             data: data,
//             header_:  headers,
//             notNeeded: false
//         }
//     }
//     work.postMessage(obj)
//     work.onmessage = e => {
//             this.table = e.data
//             this.Pdata.data = data
//             this.Pdata.header_ = headers
//             callback(this)
//             work.terminate()
//     }
//   }
//   else{
//     const work = new Worker("./workers/tableworker.js")
//     let obj = {
//     data: {
//         data: data,
//         header_:  headers,
//         notNeeded: false
//     }
// }
//     work.postMessage(obj)
//     work.onmessage = e => {
//         let dataCopy = JSON.stringify(data)
//             callback(new Frame(e.data, JSON.parse(dataCopy)))
//             work.terminate()
//     }
//     }
// } 
// reval unique, implement the proxy for rows and cols
// apply function
//  function(len: number, callback:Function){
//     const work = new Worker("./workers/tableworker.js")
//     // //.log(this.Pdata.)
//     let data:Array<any> = this.Pdata.data.slice(0, len)
//     // let header_ = ""
//     let obj = {
//         data: {
//             data: data,
//             header_: this.Header_,
//             notNeeded: false
//         }
//     }
//    work.postMessage(obj)
//    work.onmessage = e => {
//          callback(e.data)
//          work.terminate()
//    }
// }
//function(len: number, callback:Function){
//     const work = new Worker("./workers/tableworker.js")
//     // //.log(this.Pdata.)
//     let data:Array<any> = this.Pdata.data.slice(-len)
//     let header_ = ""
//     let obj = {
//         data: {
//             data: data,
//             header_:  this.Header_,
//             notNeeded: false
//         }
//     }
//    work.postMessage(obj)
//    work.onmessage = e => {
//          callback(e.data)
//          work.terminate()
//    }
// }
//  function(start:number, end:number, callback:Function){
//       if(start > end || start < 0 || end > this.Pdata.data.length) throw new Error(`
//       start > end || start < 0 || end > data.length
//       `) 
//     const work = new Worker("./workers/tableworker.js")
//     // //.log(this.Pdata.)
//     let data:Array<any> = this.Pdata.data.slice(start, end)
//     let obj = {
//         data: {
//             data: data,
//             header_:  this.Header_,
//             notNeeded: false
//         }
//     }
//    work.postMessage(obj)
//    work.onmessage = e => {
//          callback(e.data)
//          work.terminate()
//    }
// }
// function(callback:Function, column = undefined){
//     let data:Array<any> = this.Pdata.data 
//     let truthTable:Array<any> = []
//     let obj:Record<any, any> = {}
//           if(column){
//             let index:any = this.Header_.indexOf(column)
//             // //.log(index, this.Pdata.header_)
//                 if(index !== -1){
//                   data.forEach((val:Array<any>, index2)=> {
//                     let temp:Array<any> = []
//                     //.log(val[index])
//                     temp[0] = index2
//                     if(val[index] === "NaN"){
//                         temp.push(true)
//                     }
//                     else{
//                         temp.push(false)
//                     }
//                     truthTable.push(temp)
//                   })
//                 //   console.log(truthTable)
//                   obj = {
//                     data: {
//                         data: truthTable,
//                         header_:  column,
//                         notNeeded: false
//                     }
//                 }
//                     //.log(truthTable) 
//                 }
//                 else{
//                     throw new Error(`${column} does not exist`)
//                 }
//           }
//           else{
//             data.forEach((val:Array<any>, index)=> {
//                 //   truthTable.push(index)
//                   let temp:Array<any> = []
//                 //   temp.push(index)
//                 val.forEach((val, index)=> {
//                     temp[0] = index
//                    if(val === "NaN"){
//                        temp.push(true)
//                    }
//                    else{
//                        temp.push(false)
//                    }
//                 })
//                 truthTable.push(temp)
//               })
//               obj = {
//                 data: {
//                     data: truthTable,
//                     header_:  this.Header_,
//                     notNeeded: false
//                 }
//             }
//           }
//           const work = new Worker("./workers/tableworker.js")
//        work.postMessage(obj)
//        work.onmessage = e => {
//              callback(e.data)
//              work.terminate()
//        }
// }
// function(){
//     const data = this.Pdata.data
//     let operations = {
//         // byIndex(i:number){
//         // }
//     }
//     let handler ={
//         get(target:any, key:any){
//             if(key.split(",").length > 2){
//                 //.log(key, "isArray")
//                 let temp:Array<any> = []
//                 let temp2:Array<any> = []
//                 key.split(",").forEach((val)=> {
//                     if(Number(val)){
//                         temp.push(data[+val])
//                     }
//                     else{
//                        const index = this.Header_.indexOf(val)
//                        let temp3:Array<any> = []
//                        if(index !== -1){
//                         this.Pdata.data.forEach((val:Array<any>, index:number)=> {
//                                       temp3.push(val[index])
//                         })
//                        }
//                        temp2.push(temp3)
//                        temp3 = []
//                     }
//                 })
//                 if(temp.length > 0 && temp2.length > 0 ){
//                     return [temp, temp2]
//                 }
//                 else if(temp2.length > 0){
//                     return temp2
//                 }
//                 else if(temp.length > 0){
//                     return temp
//                 }
//                 else{
//                     throw new Error(key + "  Query Failed column or row does not exist");
//                 }
//             }
//             else if(Number(key)){
//                 return data[key]
//             }
//             else if(typeof key === "string"){
//                 //.log(key, "Object")
//                 const index = this.Header_.indexOf(key)
//                 let temp3:Array<any> = []
//                 if(index !== -1){
//                  this.Pdata.data.forEach((val:Array<any>, index:number)=> {
//                                temp3.push(val[index])
//                  })
//                  return temp3
//                 }
//             }
//             else{
//                 throw new Error(key + "  Query Failed column or row does not exist");
//                 //.log(key.name, "all")
//                 // //.log( Number(key))
//             }
//         }
//     }
//     return new Proxy(operations, handler)
// }
// function(inPlace:boolean = false,callback:Function,...values:Array<any>){
//     let headers:Array<any> = JSON.parse(JSON.stringify(this.Header_))
//      const data: Array<Array<any>> = JSON.parse(JSON.stringify(this.Pdata.data))
//           values.forEach((val:any)=> {
//               if(Number(val)){
//                    data.splice(val, 1)
//               }
//               else if(val === 0 || val === "0"){
//                 data.splice(val, 1)
//               }
//               else{
//                //must be column 
//                if(typeof val === "string"){
//                 const indice:number =  headers.indexOf(val)
//                     if(indice !== -1){
//                         headers.splice(indice, 1)
//                         console.log(headers)
//                         data.forEach((arr)=> {
//                             arr.splice(indice, 1)
//                         })
//                     }
//                     else{
//                      throw new Error(`${val} column does not exist`)
//                     }
//                }else{
//                    throw new Error(`${val} type not implemented`)
//                }
//               }
//           })
//               data.forEach((arr, index)=> {
//                   arr[0] = index
//               })
//           if(inPlace){
//                 const work = new Worker("./workers/tableworker.js")
//                 let obj = {
//                 data: {
//                     data: data,
//                     header_:  headers,
//                     notNeeded: false
//                 }
//             }
//             work.postMessage(obj)
//             work.onmessage = e => {
//                     this.table = e.data
//                     this.Pdata.data = data
//                     this.Pdata.header_ = headers
//                     this.Header_ = headers
//                     callback(this)
//                     work.terminate()
//             }
//           }
//           else{
//             const work = new Worker("./workers/tableworker.js")
//             let obj = {
//             data: {
//                 data: data,
//                 header_:  headers,
//                 notNeeded: false
//             }
//         }
//         work.postMessage(obj)
//         work.onmessage = e => {
//                let dataCopy = JSON.stringify(data)
//                this.Pdata.header_ = headers
//                this.Header_ = headers
//                 callback(new Frame(e.data, JSON.parse(dataCopy)))
//                 work.terminate()
//         }
//           }
// }
//# sourceMappingURL=frame.js.map