"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.twoD = exports.make_scatter_matrix = exports.plot_histogram = void 0;
const chart_js_1 = require("chart.js");
const mainHelpers_1 = require("./mainHelpers");
chart_js_1.Chart.register(chart_js_1.BarController, chart_js_1.CategoryScale, chart_js_1.LinearScale, chart_js_1.BarElement, chart_js_1.ScatterController, chart_js_1.PointElement, chart_js_1.LineElement);
// console.log(Chart)
// one dimensional
let barChart = undefined;
let scatter = [];
let el = undefined;
function make_histogram(data, bucket_size) {
    return new Promise((resolve, reject) => {
        const work = new Worker("./workers/plotWorker.js");
        work.postMessage({ type: "hist", points: data, size: bucket_size });
        work.onmessage = e => {
            if (e.data.status === "fail") {
                reject(e.data.reason);
            }
            else {
                resolve(e.data.hist);
            }
        };
    });
}
function plot_histogram(bucket_size, title = "", data) {
    return __awaiter(this, void 0, void 0, function* () {
        // console.log(data)
        if (barChart) {
            barChart.destroy();
        }
        let histogram = yield make_histogram(data, bucket_size);
        const x = Object.keys(histogram);
        const y = Object.values(histogram);
        //  console.log(x, y)
        const dataObj = {
            labels: x,
            datasets: [
                {
                    label: title,
                    data: y,
                }
            ]
        };
        //  console.log(new Chart("hist", {type: "bar", data: dataObj}));
        let c = document.createElement("canvas");
        c.width = 100;
        c.height = 100;
        c.id = "h";
        let div = document.createElement("div");
        div.style.width = "600px";
        div.style.height = "600px";
        div.className = "hist";
        div.appendChild(c);
        document.body.appendChild(div);
        // document.getElementById("har")?.appendChild(c)
        barChart = new chart_js_1.Chart(c.id, { type: "bar", data: dataObj });
    });
}
exports.plot_histogram = plot_histogram;
// chart matrix 
function make_scatter_matrix(elementId) {
    const data = this.Pdata.data;
    const num_columns = data[0].length;
    el = document.createElement("div");
    el.id = "scatter";
    el.style.display = "grid";
    let str = "";
    for (let _ of mainHelpers_1.range(num_columns)) {
        str += " 1fr";
    }
    console.log(str);
    el.style.gridTemplateColumns = str;
    document.body.appendChild(el);
    while (scatter.length !== 0) {
        let obj = scatter.pop();
        obj.destroy();
    }
    for (let i of mainHelpers_1.range(num_columns)) {
        for (let j of mainHelpers_1.range(num_columns)) {
            make_scatter_chart(mainHelpers_1.getCol(data, i), mainHelpers_1.getCol(data, j), i, j, elementId);
        }
    }
}
exports.make_scatter_matrix = make_scatter_matrix;
function make_scatter_chart(x, y, i, j, elementId) {
    const dataObj = {
        datasets: [
            {
                data: mainHelpers_1.zipToObj(x, y),
                label: `${i} ${j}`,
                pointRadius: 4,
                backgroundColor: 'blue'
            }
        ]
    };
    const chartObj = {
        type: "scatter",
        data: dataObj,
        options: {
            legend: {
                display: false
            },
        }
    };
    const c = document.createElement("canvas");
    c.width = 50;
    c.height = 50;
    c.id = i.toString() + j;
    let div = document.createElement("div");
    div.style.width = "200px";
    div.style.height = "200px";
    div.appendChild(c);
    el === null || el === void 0 ? void 0 : el.appendChild(div);
    scatter.push(new chart_js_1.Chart(c, chartObj));
}
let two = undefined;
function twoD(xs, colors, ...ys) {
    if (two) {
        two.destroy();
    }
    let points = [];
    ys.forEach((ys1) => {
        points.push(mainHelpers_1.zipToObj(xs, ys1));
    });
    const dataObj = {
        datasets: []
    };
    let colors_ = false;
    if (colors.length !== 0) {
        colors_ = true;
    }
    points.forEach((val, index) => {
        let color = "blue";
        if (colors_ && colors[index]) {
            color = colors[index];
        }
        else {
            color = "blue";
        }
        let ob = {
            data: val,
            pointRadius: 4,
            backgroundColor: color
        };
        dataObj.datasets.push(ob);
    });
    let c = document.createElement("canvas");
    c.width = 600;
    c.height = 600;
    c.id = "2D";
    let div = document.createElement("div");
    div.style.width = "600px";
    div.style.height = "600px";
    div.classList.add("twoD");
    div.appendChild(c);
    document.body.appendChild(div);
    const chartObj = {
        type: "scatter",
        data: dataObj,
        options: {
            legend: {
                display: false
            },
        }
    };
    two = new chart_js_1.Chart("2D", chartObj);
}
exports.twoD = twoD;
//# sourceMappingURL=plots.js.map