"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const wabt_1 = __importDefault(require("wabt"));
console.log(wabt_1.default);
const mem = new WebAssembly.Memory({ initial: 1 });
let initialMem = mem.buffer.byteLength;
self.onmessage = e => {
    // console.log(e.data)
    handleData(e.data);
};
function handleData(data) {
    return __awaiter(this, void 0, void 0, function* () {
        const importObject = {
            env: {
                mem
            }
        };
        let src = yield wabt_1.default();
        console.log(src);
        let datalen = data.data.mid * 2;
        // let wasm = await addstr()
        // let buffer = await wasm.arrayBuffer()
        // let mod = await WebAssembly.instantiate(wasm, importObject)
        // console.log(wasm.instance.exports)
        while (datalen > initialMem) {
            growMem();
        }
        let view = new Uint8Array(mem.buffer);
        let base = 0;
        let rowLen = 0;
        let outindex = 0;
        data.data.forEach((val, index) => {
            let cache = [];
            let internalStride = 0;
            if (index < data.mid) {
                cache = data.firstCache.get(index);
            }
            else {
                cache = data.secondCache.get(index);
            }
            val.forEach((val_, index2) => {
                let len = +cache[index2];
                len = len.toString(16);
                const fullstr = val_ + "\0o";
                let encoded = new TextEncoder("utf8").encode(fullstr);
                //  console.log(encoded, new TextDecoder("utf8").decode(encoded))
                let start = outindex.toString();
                encoded.forEach((val, index) => {
                    view[outindex] = val;
                    outindex++;
                });
                let end = encoded.byteLength.toString();
                rowLen += encoded.byteLength;
                //  outindex++
                // view.set(encoded)
                if (index < data.mid) {
                    data.firstCache.get(index)[index2] = start + "," + end;
                }
                else {
                    data.secondCache.get(index)[index2] = start + "," + end;
                }
            });
            if (index < data.mid) {
                data.firstCache.get(index).push([base, rowLen]);
            }
            else {
                data.secondCache.get(index).push([base, rowLen]);
            }
            base += rowLen;
            rowLen = 0;
        });
        for (let i = 0; i < 13; i++) {
            let c = data.firstCache.get(i);
            let [start, end] = c[c.length - 1];
            console.log(+start, +end);
            const row = new Uint8Array(mem.buffer, +start, +end);
            console.log("row: ", i, " ", new TextDecoder("utf8").decode(row).split("\0o"));
        }
    });
}
function growMem() {
    mem.grow(1);
    initialMem = mem.buffer.byteLength;
    console.log(initialMem, "buffer increased");
}
//# sourceMappingURL=wasmWorker.js.map